{
  "version": 3,
  "sources": ["../../../../../../../../../node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts", "../../../../../../../../../node_modules/next/src/client/components/redirect-status-code.ts", "../../../../../../../../../node_modules/next/src/client/components/redirect-error.ts", "../../../../../../../../../node_modules/next/src/client/components/is-next-router-error.ts"],
  "sourcesContent": ["export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n", "export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n", "import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n", "import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;MAAaA,uBAAqB,WAAA;eAArBA;;MAQAC,gCAA8B,WAAA;eAA9BA;;MAuCGC,oCAAkC,WAAA;eAAlCA;;MAPAC,6BAA2B,WAAA;eAA3BA;;MAnBAC,2BAAyB,WAAA;eAAzBA;;;AArBT,QAAMJ,wBAAwB;MACnCK,WAAW;MACXC,WAAW;MACXC,cAAc;IAChB;AAEA,QAAMC,gBAAgB,IAAIC,IAAIC,OAAOC,OAAOX,qBAAAA,CAAAA;AAErC,QAAMC,iCAAiC;AAavC,aAASG,0BACdQ,OAAc;AAEd,UACE,OAAOA,UAAU,YACjBA,UAAU,QACV,EAAE,YAAYA,UACd,OAAOA,MAAMC,WAAW,UACxB;AACA,eAAO;MACT;AACA,YAAM,CAACC,QAAQC,UAAAA,IAAcH,MAAMC,OAAOG,MAAM,GAAA;AAEhD,aACEF,WAAWb,kCACXO,cAAcS,IAAIC,OAAOH,UAAAA,CAAAA;IAE7B;AAEO,aAASZ,4BACdS,OAA8B;AAE9B,YAAMG,aAAaH,MAAMC,OAAOG,MAAM,GAAA,EAAK,CAAA;AAC3C,aAAOE,OAAOH,UAAAA;IAChB;AAEO,aAASb,mCACdiB,QAAc;AAEd,cAAQA,QAAAA;QACN,KAAK;AACH,iBAAO;QACT,KAAK;AACH,iBAAO;QACT,KAAK;AACH,iBAAO;QACT;AACE;MACJ;IACF;;;;;;;;;;;;;;;;mCC5DYC,sBAAAA;;;eAAAA;;;AAAL,QAAKA,qBAAAA,SAAAA,qBAAAA;;;;aAAAA;;;;;;;;;;;;;;;;;;;;;;;;MCECC,qBAAmB,WAAA;eAAnBA;;MAEDC,cAAY,WAAA;eAAZA;;MAgBIC,iBAAe,WAAA;eAAfA;;;;AAlBT,QAAMF,sBAAsB;AAE5B,QAAKC,eAAAA,SAAAA,eAAAA;;;aAAAA;;AAgBL,aAASC,gBAAgBC,OAAc;AAC5C,UACE,OAAOA,UAAU,YACjBA,UAAU,QACV,EAAE,YAAYA,UACd,OAAOA,MAAMC,WAAW,UACxB;AACA,eAAO;MACT;AAEA,YAAMA,SAASD,MAAMC,OAAOC,MAAM,GAAA;AAClC,YAAM,CAACC,WAAWC,IAAAA,IAAQH;AAC1B,YAAMI,cAAcJ,OAAOK,MAAM,GAAG,EAAC,EAAGC,KAAK,GAAA;AAC7C,YAAMC,SAASP,OAAOQ,GAAG,EAAC;AAE1B,YAAMC,aAAaC,OAAOH,MAAAA;AAE1B,aACEL,cAAcN,wBACbO,SAAS,aAAaA,SAAS,WAChC,OAAOC,gBAAgB,YACvB,CAACO,MAAMF,UAAAA,KACPA,cAAcG,oBAAAA;IAElB;;;;;;;;;;;;;;;mCCjCgBC,qBAAAA;;;eAAAA;;;;;AAAT,aAASA,kBACdC,OAAc;AAEd,cAAOC,GAAAA,eAAAA,iBAAgBD,KAAAA,MAAUE,GAAAA,oBAAAA,2BAA0BF,KAAAA;IAC7D;;;;;;;;",
  "names": ["HTTPAccessErrorStatus", "HTTP_ERROR_FALLBACK_ERROR_CODE", "getAccessFallbackErrorTypeByStatus", "getAccessFallbackHTTPStatus", "isHTTPAccessFallbackError", "NOT_FOUND", "FORBIDDEN", "UNAUTHORIZED", "ALLOWED_CODES", "Set", "Object", "values", "error", "digest", "prefix", "httpStatus", "split", "has", "Number", "status", "RedirectStatusCode", "REDIRECT_ERROR_CODE", "RedirectType", "isRedirectError", "error", "digest", "split", "errorCode", "type", "destination", "slice", "join", "status", "at", "statusCode", "Number", "isNaN", "RedirectStatusCode", "isNextRouterError", "error", "isRedirectError", "isHTTPAccessFallbackError"]
}
