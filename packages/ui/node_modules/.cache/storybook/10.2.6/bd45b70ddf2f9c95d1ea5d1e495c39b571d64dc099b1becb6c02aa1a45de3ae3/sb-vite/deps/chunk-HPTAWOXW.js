import {
  require_navigation,
  require_redirect
} from "./chunk-UZN7T6PA.js";
import {
  require_redirect_error
} from "./chunk-TNUOO6AX.js";
import {
  require_interop_require_wildcard
} from "./chunk-X3T6CE7U.js";
import {
  require_jsx_runtime
} from "./chunk-JQRGPQI3.js";
import {
  require_react
} from "./chunk-2JBWHE6O.js";
import {
  __commonJS
} from "./chunk-DLJ4GP37.js";

// ../../node_modules/next/dist/client/components/redirect-boundary.js
var require_redirect_boundary = __commonJS({
  "../../node_modules/next/dist/client/components/redirect-boundary.js"(exports, module) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      RedirectBoundary: function() {
        return RedirectBoundary;
      },
      RedirectErrorBoundary: function() {
        return RedirectErrorBoundary;
      }
    });
    var _interop_require_wildcard = require_interop_require_wildcard();
    var _jsxruntime = require_jsx_runtime();
    var _react = _interop_require_wildcard._(require_react());
    var _navigation = require_navigation();
    var _redirect = require_redirect();
    var _redirecterror = require_redirect_error();
    function HandleRedirect({ redirect, reset, redirectType }) {
      const router = (0, _navigation.useRouter)();
      (0, _react.useEffect)(() => {
        _react.default.startTransition(() => {
          if (redirectType === _redirecterror.RedirectType.push) {
            router.push(redirect, {});
          } else {
            router.replace(redirect, {});
          }
          reset();
        });
      }, [
        redirect,
        redirectType,
        reset,
        router
      ]);
      return null;
    }
    var RedirectErrorBoundary = class extends _react.default.Component {
      constructor(props) {
        super(props);
        this.state = {
          redirect: null,
          redirectType: null
        };
      }
      static getDerivedStateFromError(error) {
        if ((0, _redirecterror.isRedirectError)(error)) {
          const url = (0, _redirect.getURLFromRedirectError)(error);
          const redirectType = (0, _redirect.getRedirectTypeFromError)(error);
          if ("handled" in error) {
            return {
              redirect: null,
              redirectType: null
            };
          }
          return {
            redirect: url,
            redirectType
          };
        }
        throw error;
      }
      // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.
      render() {
        const { redirect, redirectType } = this.state;
        if (redirect !== null && redirectType !== null) {
          return (0, _jsxruntime.jsx)(HandleRedirect, {
            redirect,
            redirectType,
            reset: () => this.setState({
              redirect: null
            })
          });
        }
        return this.props.children;
      }
    };
    function RedirectBoundary({ children }) {
      const router = (0, _navigation.useRouter)();
      return (0, _jsxruntime.jsx)(RedirectErrorBoundary, {
        router,
        children
      });
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

export {
  require_redirect_boundary
};
//# sourceMappingURL=chunk-HPTAWOXW.js.map
