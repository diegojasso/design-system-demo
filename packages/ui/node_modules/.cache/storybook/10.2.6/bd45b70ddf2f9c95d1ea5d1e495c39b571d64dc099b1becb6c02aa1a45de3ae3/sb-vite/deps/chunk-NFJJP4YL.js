import {
  require_set_attributes_from_props
} from "./chunk-25QI7FFU.js";
import {
  __commonJS
} from "./chunk-DLJ4GP37.js";

// ../../node_modules/next/dist/client/head-manager.js
var require_head_manager = __commonJS({
  "../../node_modules/next/dist/client/head-manager.js"(exports, module) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      default: function() {
        return initHeadManager;
      },
      isEqualNode: function() {
        return isEqualNode;
      }
    });
    var _setattributesfromprops = require_set_attributes_from_props();
    function reactElementToDOM({ type, props }) {
      const el = document.createElement(type);
      (0, _setattributesfromprops.setAttributesFromProps)(el, props);
      const { children, dangerouslySetInnerHTML } = props;
      if (dangerouslySetInnerHTML) {
        el.innerHTML = dangerouslySetInnerHTML.__html || "";
      } else if (children) {
        el.textContent = typeof children === "string" ? children : Array.isArray(children) ? children.join("") : "";
      }
      return el;
    }
    function isEqualNode(oldTag, newTag) {
      if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {
        const nonce = newTag.getAttribute("nonce");
        if (nonce && !oldTag.getAttribute("nonce")) {
          const cloneTag = newTag.cloneNode(true);
          cloneTag.setAttribute("nonce", "");
          cloneTag.nonce = nonce;
          return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);
        }
      }
      return oldTag.isEqualNode(newTag);
    }
    function updateElements(type, components) {
      var _a;
      const headEl = document.querySelector("head");
      if (!headEl) return;
      const oldTags = new Set(headEl.querySelectorAll(`${type}[data-next-head]`));
      if (type === "meta") {
        const metaCharset = headEl.querySelector("meta[charset]");
        if (metaCharset !== null) {
          oldTags.add(metaCharset);
        }
      }
      const newTags = [];
      for (let i = 0; i < components.length; i++) {
        const component = components[i];
        const newTag = reactElementToDOM(component);
        newTag.setAttribute("data-next-head", "");
        let isNew = true;
        for (const oldTag of oldTags) {
          if (isEqualNode(oldTag, newTag)) {
            oldTags.delete(oldTag);
            isNew = false;
            break;
          }
        }
        if (isNew) {
          newTags.push(newTag);
        }
      }
      for (const oldTag of oldTags) {
        (_a = oldTag.parentNode) == null ? void 0 : _a.removeChild(oldTag);
      }
      for (const newTag of newTags) {
        if (newTag.tagName.toLowerCase() === "meta" && newTag.getAttribute("charset") !== null) {
          headEl.prepend(newTag);
        }
        headEl.appendChild(newTag);
      }
    }
    function initHeadManager() {
      return {
        mountedInstances: /* @__PURE__ */ new Set(),
        updateHead: (head) => {
          const tags = {};
          head.forEach((h) => {
            if (
              // If the font tag is loaded only on client navigation
              // it won't be inlined. In this case revert to the original behavior
              h.type === "link" && h.props["data-optimized-fonts"]
            ) {
              if (document.querySelector(`style[data-href="${h.props["data-href"]}"]`)) {
                return;
              } else {
                h.props.href = h.props["data-href"];
                h.props["data-href"] = void 0;
              }
            }
            const components = tags[h.type] || [];
            components.push(h);
            tags[h.type] = components;
          });
          const titleComponent = tags.title ? tags.title[0] : null;
          let title = "";
          if (titleComponent) {
            const { children } = titleComponent.props;
            title = typeof children === "string" ? children : Array.isArray(children) ? children.join("") : "";
          }
          if (title !== document.title) document.title = title;
          [
            "meta",
            "base",
            "link",
            "style",
            "script"
          ].forEach((type) => {
            updateElements(type, tags[type] || []);
          });
        }
      };
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

export {
  require_head_manager
};
//# sourceMappingURL=chunk-NFJJP4YL.js.map
