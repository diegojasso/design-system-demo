{
  "version": 3,
  "sources": ["../../../../../../../../../node_modules/next/src/client/components/redirect-boundary.tsx"],
  "sourcesContent": ["'use client'\nimport React, { useEffect } from 'react'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useRouter } from './navigation'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { RedirectType, isRedirectError } from './redirect-error'\n\ninterface RedirectBoundaryProps {\n  router: AppRouterInstance\n  children: React.ReactNode\n}\n\nfunction HandleRedirect({\n  redirect,\n  reset,\n  redirectType,\n}: {\n  redirect: string\n  redirectType: RedirectType\n  reset: () => void\n}) {\n  const router = useRouter()\n\n  useEffect(() => {\n    React.startTransition(() => {\n      if (redirectType === RedirectType.push) {\n        router.push(redirect, {})\n      } else {\n        router.replace(redirect, {})\n      }\n      reset()\n    })\n  }, [redirect, redirectType, reset, router])\n\n  return null\n}\n\nexport class RedirectErrorBoundary extends React.Component<\n  RedirectBoundaryProps,\n  { redirect: string | null; redirectType: RedirectType | null }\n> {\n  constructor(props: RedirectBoundaryProps) {\n    super(props)\n    this.state = { redirect: null, redirectType: null }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isRedirectError(error)) {\n      const url = getURLFromRedirectError(error)\n      const redirectType = getRedirectTypeFromError(error)\n      if ('handled' in error) {\n        // The redirect was already handled. We'll still catch the redirect error\n        // so that we can remount the subtree, but we don't actually need to trigger the\n        // router.push.\n        return { redirect: null, redirectType: null }\n      }\n\n      return { redirect: url, redirectType }\n    }\n    // Re-throw if error is not for redirect\n    throw error\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    const { redirect, redirectType } = this.state\n    if (redirect !== null && redirectType !== null) {\n      return (\n        <HandleRedirect\n          redirect={redirect}\n          redirectType={redirectType}\n          reset={() => this.setState({ redirect: null })}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport function RedirectBoundary({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n  return (\n    <RedirectErrorBoundary router={router}>{children}</RedirectErrorBoundary>\n  )\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;MAgFgBA,kBAAgB,WAAA;eAAhBA;;MA3CHC,uBAAqB,WAAA;eAArBA;;;;;4DApCoB;;;;AAWjC,aAASC,eAAe,EACtBC,UACAC,OACAC,aAAY,GAKb;AACC,YAAMC,UAASC,GAAAA,YAAAA,WAAS;AAExBC,OAAAA,GAAAA,OAAAA,WAAU,MAAA;AACRC,eAAAA,QAAMC,gBAAgB,MAAA;AACpB,cAAIL,iBAAiBM,eAAAA,aAAaC,MAAM;AACtCN,mBAAOM,KAAKT,UAAU,CAAC,CAAA;UACzB,OAAO;AACLG,mBAAOO,QAAQV,UAAU,CAAC,CAAA;UAC5B;AACAC,gBAAAA;QACF,CAAA;MACF,GAAG;QAACD;QAAUE;QAAcD;QAAOE;OAAO;AAE1C,aAAO;IACT;AAEO,QAAML,wBAAN,cAAoCQ,OAAAA,QAAMK,UAAS;MAIxDC,YAAYC,OAA8B;AACxC,cAAMA,KAAAA;AACN,aAAKC,QAAQ;UAAEd,UAAU;UAAME,cAAc;QAAK;MACpD;MAEA,OAAOa,yBAAyBC,OAAY;AAC1C,aAAIC,GAAAA,eAAAA,iBAAgBD,KAAAA,GAAQ;AAC1B,gBAAME,OAAMC,GAAAA,UAAAA,yBAAwBH,KAAAA;AACpC,gBAAMd,gBAAekB,GAAAA,UAAAA,0BAAyBJ,KAAAA;AAC9C,cAAI,aAAaA,OAAO;AAItB,mBAAO;cAAEhB,UAAU;cAAME,cAAc;YAAK;UAC9C;AAEA,iBAAO;YAAEF,UAAUkB;YAAKhB;UAAa;QACvC;AAEA,cAAMc;MACR;;MAGAK,SAA0B;AACxB,cAAM,EAAErB,UAAUE,aAAY,IAAK,KAAKY;AACxC,YAAId,aAAa,QAAQE,iBAAiB,MAAM;AAC9C,kBACE,GAAA,YAAA,KAACH,gBAAAA;YACCC;YACAE;YACAD,OAAO,MAAM,KAAKqB,SAAS;cAAEtB,UAAU;YAAK,CAAA;;QAGlD;AAEA,eAAO,KAAKa,MAAMU;MACpB;IACF;AAEO,aAAS1B,iBAAiB,EAAE0B,SAAQ,GAAiC;AAC1E,YAAMpB,UAASC,GAAAA,YAAAA,WAAS;AACxB,cACE,GAAA,YAAA,KAACN,uBAAAA;QAAsBK;;;IAE3B;;;;;;;;",
  "names": ["RedirectBoundary", "RedirectErrorBoundary", "HandleRedirect", "redirect", "reset", "redirectType", "router", "useRouter", "useEffect", "React", "startTransition", "RedirectType", "push", "replace", "Component", "constructor", "props", "state", "getDerivedStateFromError", "error", "isRedirectError", "url", "getURLFromRedirectError", "getRedirectTypeFromError", "render", "setState", "children"]
}
